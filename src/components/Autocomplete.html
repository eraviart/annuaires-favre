<svelte:window on:click="windowOnClick(event)" on:keydown="windowOnKeyDown(event)" />

<div on:click="event.stopPropagation()">
  <input
    autocomplete="off"
    class="{class}"
    {disabled}
    {placeholder}
    {required}
    on:blur="onBlur(event)"
    on:focus="onFocus(event)"
    on:input="onInput(event)"
    on:keydown="onKeyDown(event)"
    ref:input
    type="text"
    value="{name}"
  >
  {#if isOpen}
    <ul class="absolute bg-white border list-reset shadow-md z-10" on:mousedown="event.preventDefault()" ref:list>
      {#each filteredItems as result, index}
        <li class="{index === currentItemIndex ? 'bg-black text-white ' : ''} hover:bg-grey-darker hover:text-white p-1" on:click="close(index)">
          {@html result.label}
        </li>
      {/each}
    </ul>
  {/if}
  {#if isLoading}
    <slot>
      <p class="fallback">Chargement des donn√©es en cours...</p>
    </slot>
  {/if}
</div>

<script>
  import { slugify } from "../strings"

  const regExpEscape = (s) => {
    return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&")
  }

  export default {
    data() {
      return {
        class: "",
        currentItemIndex: -1,
        disabled: false,
        filteredItems: [],
        fromStart: true, // Default type ahead
        isLoading: false,
        isOpen: false,
        items: [],
        minChar: 2,
        name: null,
        placeholder: "",
        required: false,
      }
    },
    methods: {
      close(index) {
        const { filteredItems } = this.get()
        const result = filteredItems[index]
        this.set({ currentItemIndex: index, name: result.name })
        this.fire("select", result)
        this.refs.input.blur()  // onBlur closes autocompletion menu.
      },
      async onBlur(event) {
        this.set({ isLoading: false, isOpen: false })
        this.fire("blur", event)
      },
      async onFocus(event) {
        const { filteredItems, name } = this.get()
        if (event.target.value === name ) {
          this.set({ isOpen: filteredItems.length > 0 })
        } else {
          this.set({ isLoading: true })
          this.fire("input", event.target.value)
        }
        this.fire("focus", event)
      },
      async onInput(event) {
        this.set({ isLoading: true })
        this.fire("input", event.target.value)
      },
      onKeyDown(event) {
        let { currentItemIndex, filteredItems } = this.get()

        switch (event.keyCode) {
          case 13:
            // Enter
            event.preventDefault() // Prevent form submission.
            if (currentItemIndex === -1) {
              currentItemIndex = 0 // Default select first item of list
            }
            this.close(currentItemIndex)
            // Simulate a Tab key down event, to move focus to next form field.
            this.onKeyDown({ keyCode: 9 })
            break
          case 27:
            // Escape
            event.preventDefault()
            this.refs.input.blur()
            break
          case 38:
            // Arrow Up
            if (currentItemIndex > 0) {
              this.set({ currentItemIndex: currentItemIndex - 1 })
            }
            break
          case 40:
            // Arrow Down
            if (currentItemIndex < filteredItems.length - 1) {
              this.set({ currentItemIndex: currentItemIndex + 1 })
            }
            break
        }
      },
      windowOnClick(/* event */) {
        if (this.get().isOpen) {
          // Close autocompleter when a click occurs outside.
          this.refs.input.blur()
        }
      },
      windowOnKeyDown(event) {
        if (event.keyCode === 27) {
          // Close autocompleter when escape is pressed.
          this.refs.input.blur()
        }
      },
    },
    onupdate({ changed, current }) {
      const items = current.items
      if (changed.items && items.length) {
        const { name } = this.get()
        const slug = slugify(name)
        const filteredItems = items
          // .filter(item => {
          //   return fromStart
          //     ? slugify(item.name).startsWith(slugify(name))
          //     : slugify(item.name).includes(slugify(name))
          // })
          .map(item => {
            const nameTrimmed = name === null ? "" : name.trim()
            const itemNameHighlighted =
              nameTrimmed === ""
                ? item.name
                : item.name.replace(RegExp(regExpEscape(nameTrimmed), "i"), "<b>$&</b>")
            return {
              ...item,
              label: `${itemNameHighlighted} (${item.id})`,
            }
          })
        this.set({
          currentItemIndex: filteredItems.findIndex(item => slugify(item.name) === slug),
          filteredItems,
          isLoading: false,
          isOpen: filteredItems.length > 0,
          items,
        })
      }
    },
  }
</script>